<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="UTF-8" />
  <title>ì´ê¸€ìŠ¤ ê³µê²© ì„±ê³¼í‰ê°€ ì‹œìŠ¤í…œ v1.0.0</title>
  <link rel="apple-touch-icon" href="EG LOGO.png">
  <style>
    body { font-family: sans-serif; margin: 30px; }
    h1 { margin-bottom: 10px; }
    .lineup-input { margin-bottom: 20px; }
    .lineup-input input { margin: 2px; }
    .actions { margin: 6px 0; display:flex; gap:8px; }

    #stepProgress { margin: 12px 0 16px; display: flex; flex-wrap: wrap; gap: 8px; }
    .stepBox {
      padding: 5px 10px; border-radius: 5px; border: 1px solid #ccc;
      background-color: #eee; font-weight: bold; font-size: 14px;
    }
    .stepBox.active { background-color: #007bff; color: #fff; border-color: #007bff; }

    #currentInputLine {
      font-size: 16px; margin-top: 10px; margin-bottom: 6px;
      font-weight: bold; color: #333;
    }
    #hint { font-size: 12px; color: #666; margin-bottom: 16px; }

    .log { margin-top: 24px; border-top: 1px solid #ccc; padding-top: 16px; }
    table { width: 100%; border-collapse: collapse; margin-top: 10px; }
    th, td { border: 1px solid #aaa; padding: 6px; text-align: center; }
    th { background-color: #f2f2f2; }
    .flash-bg { background-color: #cce5ff; transition: background-color 0.6s ease; }

    .topRow { display: flex; align-items: flex-start; gap: 16px; }

    #legendBox {
      flex: 0 0 300px; max-width: 300px;
      margin: 15px 0 8px 0; padding: 10px 15px;
      border: 1px solid #cfd8e3; background-color: #e9eef5;
      border-radius: 6px;
    }
    #legendBox strong { display:block; margin-bottom:4px; }
    #legendBox ul { list-style: none; padding-left: 0; margin: 6px 0 0; }
    #legendBox li { margin: 4px 0; }
    .red { color: red; font-weight: bold; }
    .green { color: green; font-weight: bold; }
    .yellow { color: #b8860b; font-weight: bold; }

    #lineupSummary {
      flex: 1 1 auto;
      border: 1px solid #ddd; background: #f9f9f9;
      padding: 12px; display: none;
    }
    #lineupSummary h3 { margin: 0 0 8px; }

/* ìµœê·¼ ì´ë‹ ë°°ì§€ / ì¼ì • ë°°ì§€ â†’ íšŒìƒ‰ í†¤ */
/* ìµœê·¼ ì´ë‹ ë°°ì§€ â†’ ì´ˆë¡ í†¤ */
.inningTag{
  margin-left:8px; padding:2px 8px; border-radius:9999px;
  background:#dcfce7; color:#166534; font-size:12px; font-weight:700; border:1px solid #bbf7d0;
}
.schedBadge{
  margin-left:8px; padding:2px 8px; border-radius:9999px;
  background:#f3f4f6; color:#374151; font-size:12px; font-weight:700; border:1px solid #e5e7eb;
}

/* ì‹¤ì‹œê°„ ê³µê²©ì ìˆ˜ ë°°ì§€: ì¤‘ë¦½ ë°°ê²½(íšŒìƒ‰) */
.liveScore {
  display:inline-block; margin:0 1px; padding:0 5px; border-radius:9999px;
  background:#f8fafc; border:1px solid #e5e7eb; color:#374151;
  font-size:12px; font-weight:700;
}

/* ì ìˆ˜ ê°’ì˜ ë¶€í˜¸ë³„ ìƒ‰ìƒ */
.num.pos { color:#1d4ed8; }  /* + íŒŒë‘ */
.num.neg { color:#b91c1c; }  /* - ë¹¨ê°• */
.num.zero{ color:#6b7280; }  /* 0 íšŒìƒ‰ */


    #lineupWrapper {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }
    .lineupPanel {
      border: 1px solid #e2e2e2; background: #fff;
      padding: 10px; min-width: 220px;
    }
    .lineupPanel h4 { margin: 0 0 6px; font-size: 14px; }
    .key { width: 28px; display: inline-block; color: #888; }


    #starterList > div, #benchList > div { border-bottom: 1px dashed #eee; padding: 2px 0; }

    .btn-danger { background:#dc3545; color:#fff; border:none; padding:6px 10px; cursor:pointer; }
    .btn { background:#eee; border:1px solid #ccc; padding:6px 10px; cursor:pointer; }

    .miniPlay{
      margin-left:6px; padding:1px 6px; border-radius:9999px;
      background:#eef2f7; color:#333; font-size:12px; font-weight:600;
    }

    .schedRow{ display:flex; gap:8px; align-items:center; margin:6px 0 10px; }
    .schedRow input{ padding:6px 8px; border:1px solid #ccc; border-radius:4px;}

    .editing td.ed { outline: 2px dashed #93c5fd; background:#f3f8ff; }

    /* íƒ€ì„ ë³´ì •ì ìˆ˜ ë°•ìŠ¤ */
    #paAdjBox{ margin-top:10px; padding-top:8px; border-top:1px dashed #e5e7eb; }
    #paAdjBody table{ width:100%; border-collapse:collapse; }
    #paAdjBody td{ padding:4px 6px; font-size:12px; }
    #paAdjBody td:last-child{ text-align:right; font-weight:700; }

    /* ë³´ì • ìš”ì•½ */
    #paAdjSummary { margin-top:8px; font-size:12px; color:#374151; }
    #paAdjSummary h5 { margin:8px 0 4px; font-size:12px; }
    #paAdjSummary ul { margin:4px 0 0; padding-left:16px; }
/* íƒ€ìˆœ ìˆ«ìì™€ ë°°ì§€ ì‚¬ì´ ê°„ê²© ìµœì†Œí™” */
#starterList .key,
#benchList .key{
  width:auto;           /* ê³ ì •í­ ì œê±° */
  min-width: 14px;      /* ë„ˆë¬´ ë¶™ì§€ ì•Šê²Œ ìµœì†Œí­ë§Œ */
  display:inline-block;
  text-align:right;
  margin-right: 2px;    /* ìˆ«ìì™€ ë°°ì§€ ì‚¬ì´ ì—¬ë°± */
}

/* ë°°ì§€ ìì²´ ì¢Œìš° ì—¬ë°±ë„ ì‚´ì§ë§Œ */
#starterList .liveScore,
#benchList .liveScore{
  margin: 0 1px;
}
  </style>
</head>
<body>
  <h1>
    <img src="EG LOGO.png" alt="ì´ê¸€ìŠ¤ ë¡œê³ " style="width:50px;height:50px;vertical-align:middle;margin-right:8px;">
    ì´ê¸€ìŠ¤ ê³µê²© ì„±ê³¼í‰ê°€ -<span style="font-size:.7em;color:#888;">ì‹œìŠ¤í…œ v1.1</span>
  </h1>

  <!-- ë¼ì¸ì—…/ì¼ì •ëª… ì…ë ¥ -->
  <div class="lineup-input" id="lineupInput">
    <div class="schedRow">
      <label for="scheduleName"><strong>ì¼ì •ëª…:</strong></label>
      <input id="scheduleName" placeholder="ì˜ˆ) '25 í˜¸í¬ìŠ¤ ë¦¬ê·¸ê²½ê¸° 1" style="min-width:280px;">
    </div>

    <div><strong>ì„ ë°œ (1~9ë²ˆ):</strong></div>
    <div id="starterInputs"></div>
    <div style="margin-top:6px;"><strong>ëŒ€ê¸° (q~t):</strong></div>
    <div id="benchInputs"></div>
    <div class="actions" style="margin-top:8px;">
      <button id="applyLineupBtn" type="button" class="btn">ë¼ì¸ì—… ì ìš©</button>
    </div>
  </div>

  <!-- ì§„í–‰ ìŠ¤í… í‘œì‹œ -->
  <div id="stepProgress"></div>

  <div class="topRow">
    <div id="legendBox">
      <strong>ì„ íƒì§€ (ë‹¨ì¶•í‚¤ ì…ë ¥ ê°€ëŠ¥):</strong>
      <ul id="legendList"></ul>
    </div>

    <div id="lineupSummary">
      <!-- í—¤ë”: 'ë¼ì¸ì—…' ë°”ë¡œ ì˜¤ë¥¸ìª½ì— ìµœê·¼ ì´ë‹ ë°°ì§€, ìš°ì¸¡ì—” ì¼ì • ë°°ì§€ -->
      <div style="display:flex;align-items:center;justify-content:space-between;margin:0 0 8px;">
        <h3 style="margin:0; display:flex; align-items:center; gap:8px;">
          ë¼ì¸ì—…
          <span id="currentInningTag" class="inningTag" style="display:none;"></span>
        </h3>
        <div style="display:flex;align-items:center;">
          <span id="schedulePreview" class="schedBadge" style="display:none;"></span>
        </div>
      </div>

      <div id="lineupWrapper">
        <div class="lineupPanel">
          <h4>ì„ ë°œ (1~9)</h4>
          <div id="starterList"></div>
        </div>
        <div class="lineupPanel">
          <h4>êµì²´ (q~t)</h4>
          <div id="benchList"></div>

          <!-- â¬‡ï¸ íƒ€ì„ ë³´ì •ì ìˆ˜ -->
          <div id="paAdjBox">
            <h4 style="margin:6px 0 4px;">íƒ€ì„ ë³´ì •ì ìˆ˜</h4>
            <div id="paAdjBody" style="color:#6b7280; font-size:12px;">ë¡œê·¸ë¥¼ ì…ë ¥í•˜ë©´ ìë™ ê³„ì‚°ë©ë‹ˆë‹¤.</div>
            <!-- â¬‡ï¸ ë³´ì • ìš”ì•½ (ì‹ ê·œ) -->
            <div id="paAdjSummary"></div>
          </div>
        </div>
      </div>
    </div>
  </div>

  <div id="currentInputLine">[í˜„ì¬ ì…ë ¥ ì¤‘] â†’ </div>
  <div id="hint">ESC: ì „ì²´ ì´ˆê¸°í™”(ìŠ¤í…ë§Œ) / Backspace: í•œ ë‹¨ê³„ ë¡¤ë°±</div>

  <!-- ë¡œê·¸ -->
  <div class="log">
    <div style="display:flex; align-items:center; justify-content:space-between; margin-bottom:5px;">
      <!-- 'ì…ë ¥ ë¡œê·¸' ë°”ë¡œ ì˜¤ë¥¸ìª½ì— 'ë¡œê·¸ ìˆ˜ì •' ë²„íŠ¼ -->
      <div style="display:flex; align-items:center; gap:8px;">
        <h2 style="margin:0;">ì…ë ¥ ë¡œê·¸</h2>
        <button id="toggleEdit" class="btn">ë¡œê·¸ ìˆ˜ì •: OFF</button>
      </div>
      <div class="actions">
        <button id="deleteSelected" class="btn">ì„ íƒ ì‚­ì œ</button>
        <button id="exportCsv" class="btn">CSV ë‹¤ìš´ë¡œë“œ</button>
        <button id="copyCsv" class="btn">CSV ë³µì‚¬</button>
        <button id="resetAll" class="btn-danger" title="ë¼ì¸ì—…/ì§„í–‰ìƒíƒœ/ë¡œê·¸ ì „ì²´ ì‚­ì œ">ì „ì²´ ì´ˆê¸°í™”</button>
      </div>
    </div>
    <table id="logTable">
      <thead>
        <tr>
          <th><input type="checkbox" id="selectAll"></th>
          <th>#</th>
          <th>ì´ë‹</th>
          <th>íƒ€ìˆœ</th>
          <th>ì„ ìˆ˜</th>
          <th>ì´ë²¤íŠ¸</th>
          <th>ë°©í–¥1</th>
          <th>ë°©í–¥2</th>
          <th>ì„±ê²©</th>
          <th>ì¢…ë¥˜</th>
          <th>ê²°ê³¼</th>
          <th>ê¸°ë¡</th>
          <th>ì½”ë“œ</th>
          <th>ì ìˆ˜</th>
        </tr>
      </thead>
      <tbody></tbody>
    </table>
  </div>

<script>
/* ============== ê·œì¹™ í…Œì´ë¸”(ì´ˆê¸° ìë™ ê¸°ì…ìš©) ============== */
window.CODE_RULES = [
  { code: "B-SO-O", score: -1.5, when: { event: "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]", type: "[ì‚¼ì§„]", result: "[ì•„ì›ƒ]" } },
  { code: "B-SO-S", score: 0,    when: { event: "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]", type: "[ì‚¼ì§„]", result: "[ì¶œë£¨]" } },
  { code: "B-BB",   score: 1,    when: { event: "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]", type: "[ë³¼ë„·]", result: "[ì¶œë£¨]" } },
  { code: "B-BB",   score: 1,    when: { event: "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]", type: "[ì‚¬êµ¬]", result: "[ì¶œë£¨]" } },

  { code: "BR-2ndQ", score: 1,   when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ë„ë£¨]", result: "[2ë£¨ ë„ë£¨ Q]" } },
  { code: "BR-2nd",  score: 0.5, when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ë„ë£¨]", result: "[2ë£¨ ë„ë£¨]" } },
  { code: "BR-3rd",  score: 1,   when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ë„ë£¨]", result: "[3ë£¨ ë„ë£¨]" } },

  { code: "BR-ETB-1", score: 1,   when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì§„ë£¨]", result: "[2ë£¨ ETB]" } },
  { code: "BR-ETB-1", score: 1,   when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì§„ë£¨]", result: "[3ë£¨ ETB]" } },
  { code: "BR-ETB-2", score: 1.5, when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì§„ë£¨]", result: "[í™ˆ ETB]" } },
  { code: "BR-WP",    score: 0,   when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì§„ë£¨]", result: "[í­íˆ¬ë¡œ ì§„ë£¨]" } },
  { code: "BR-FE",    score: 0,   when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì§„ë£¨]", result: "[ì‹¤ì±…ìœ¼ë¡œ ì§„ë£¨]" } },
  { code: "BR-SF",    score: 0,   when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì§„ë£¨]", result: "[ì§„ë£¨íƒ€ë¡œ ì§„ë£¨]" } },

  { code: "BR-E-1", score: -1.5, when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒ]", result: "[ë„ë£¨ì/ì£¼ë£¨ì‚¬ (2ë£¨)]" } },
  { code: "BR-E-1", score: -1.5, when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒ]", result: "[ë„ë£¨ì/ì£¼ë£¨ì‚¬ (3ë£¨)]" } },
  { code: "BR-E-2", score: -2,   when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒ]", result: "[ë„ë£¨ì/ì£¼ë£¨ì‚¬ (í™ˆ)]" } },

  { code: "BR-E-3", score: -1,   when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì§„ë£¨ ê¸°íšŒ ë†“ì¹¨]", result: "[ì§„ë£¨ ê¸°íšŒ ë†“ì¹¨ (2ë£¨/3ë£¨)]" } },
  { code: "BR-E-5", score: -1.5, when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì§„ë£¨ ê¸°íšŒ ë†“ì¹¨]", result: "[ì§„ë£¨ ê¸°íšŒ ë†“ì¹¨ (í™ˆ)]" } },
  { code: "BR-E-4", score: -0.5, when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì§„ë£¨ ê¸°íšŒ ë†“ì¹¨]", result: "[ë„ë£¨ ê¸°íšŒ ë†“ì¹¨]" } },

  { code: "BR-STP-S", score: 1,  when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì£¼ë£¨ ì‘ì „]", result: "[ì£¼ë£¨ ì‘ì „ ì„±ê³µ]" } },
  { code: "STP",      score: 0,  when: { event: "[ì£¼ë£¨ ì´ë²¤íŠ¸]", type: "[ì£¼ë£¨ ì‘ì „]", result: "[ì£¼ë£¨ ì‘ì „ ì‹¤íŒ¨]" } },

  { code: "B-G-O",   score: -1,  when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]",     detail: "[ë•…ë³¼]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-G-O",   score: -1,  when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]",     detail: "[ë•…ë³¼]", result: "[ì„ í–‰ì£¼ì ì•„ì›ƒ]" } },

  { code: "B-G-O-H", score: 0,   when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]",   detail: "[ë•…ë³¼]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-G-O-H", score: 0,   when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]",   detail: "[ë•…ë³¼]", result: "[ì„ í–‰ì£¼ì ì•„ì›ƒ]" } },
  { code: "B-G-O-H", score: 0,   when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ë‚´ì•¼ì•ˆíƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-G-O-H", score: 0,   when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ë‚´ì•¼ì•ˆíƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì„ í–‰ì£¼ì ì•„ì›ƒ]" } },

  { code: "B-G-SF", score: 0.5, when: { event:"[íƒ€ê²© ì´ë²¤íŠ¸]", dir1:"[1ë£¨ìˆ˜]", type:"[í¬ìƒíƒ€/íƒ€ì ì„±]", detail:"[ë•…ë³¼]" } },
  { code: "B-G-SF", score: 0.5, when: { event:"[íƒ€ê²© ì´ë²¤íŠ¸]", dir1:"[2ë£¨ìˆ˜]", type:"[í¬ìƒíƒ€/íƒ€ì ì„±]", detail:"[ë•…ë³¼]" } },
  { code: "B-G-SF", score: 0.5, when: { event:"[íƒ€ê²© ì´ë²¤íŠ¸]", dir1:"[3ë£¨ìˆ˜]", type:"[í¬ìƒíƒ€/íƒ€ì ì„±]", detail:"[ë•…ë³¼]" } },
  { code: "B-G-SF", score: 0.5, when: { event:"[íƒ€ê²© ì´ë²¤íŠ¸]", dir1:"[ìœ ê²©ìˆ˜]", type:"[í¬ìƒíƒ€/íƒ€ì ì„±]", detail:"[ë•…ë³¼]" } },

  { code: "B-G-S",   score: 0.5, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ë³‘ì‚´íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì¶œë£¨]" } },
  { code: "B-G-O",   score: -1,  when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ë³‘ì‚´íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-G-O",   score: -1,  when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ë³‘ì‚´íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì„ í–‰ì£¼ì ì•„ì›ƒ]" } },
  { code: "B-GD-O",  score: -2,  when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ë³‘ì‚´íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ë”ë¸” ì•„ì›ƒ]" } },

  { code: "B-G-S",   score: 0.5, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]",     detail: "[ë•…ë³¼]", result: "[ì¶œë£¨]" } },
  { code: "B-G-S",   score: 0.5, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ë‚´ì•¼ì•ˆíƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì¶œë£¨]" } },

  { code: "B-G-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì¶œë£¨]", dir1: "[íˆ¬ìˆ˜]" } },
  { code: "B-G-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì¶œë£¨]", dir1: "[í¬ìˆ˜]" } },
  { code: "B-G-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì¶œë£¨]", dir1: "[1ë£¨ìˆ˜]" } },
  { code: "B-G-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì¶œë£¨]", dir1: "[2ë£¨ìˆ˜]" } },
  { code: "B-G-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì¶œë£¨]", dir1: "[3ë£¨ìˆ˜]" } },
  { code: "B-G-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]", detail: "[ë•…ë³¼]", result: "[ì¶œë£¨]", dir1: "[ìœ ê²©ìˆ˜]" } },

  { code: "B-L-O",   score: -1,  when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", detail: "[ì§ì„ íƒ€]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-L-O",   score: -1,  when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", detail: "[ì§ì„ íƒ€]", result: "[ì„ í–‰ì£¼ì ì•„ì›ƒ]" } },

  { code: "B-L-O-H", score: 0,   when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]", detail: "[ì§ì„ íƒ€]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-L-O-H", score: 0,   when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[1ë£¨íƒ€ì„±]", detail: "[ì§ì„ íƒ€]", result: "[ì„ í–‰ì£¼ì ì•„ì›ƒ]" } },

  { code: "B-L-S", score: 0.5, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", detail: "[ì§ì„ íƒ€]", result: "[ì¶œë£¨]" } },

  { code: "B-L-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[íˆ¬ìˆ˜]",   type: "[1ë£¨íƒ€ì„±]", detail: "[ì§ì„ íƒ€]", result: "[ì¶œë£¨]" } },
  { code: "B-L-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[í¬ìˆ˜]",   type: "[1ë£¨íƒ€ì„±]", detail: "[ì§ì„ íƒ€]", result: "[ì¶œë£¨]" } },
  { code: "B-L-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[1ë£¨ìˆ˜]",  type: "[1ë£¨íƒ€ì„±]", detail: "[ì§ì„ íƒ€]", result: "[ì¶œë£¨]" } },
  { code: "B-L-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[2ë£¨ìˆ˜]",  type: "[1ë£¨íƒ€ì„±]", detail: "[ì§ì„ íƒ€]", result: "[ì¶œë£¨]" } },
  { code: "B-L-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[3ë£¨ìˆ˜]",  type: "[1ë£¨íƒ€ì„±]", detail: "[ì§ì„ íƒ€]", result: "[ì¶œë£¨]" } },
  { code: "B-L-S-H", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ìœ ê²©ìˆ˜]", type: "[1ë£¨íƒ€ì„±]", detail: "[ì§ì„ íƒ€]", result: "[ì¶œë£¨]" } },

  { code: "B-IF-O", score: -1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[íˆ¬ìˆ˜]",   detail: "[ëœ¬ê³µ]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-IF-O", score: -1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[í¬ìˆ˜]",   detail: "[ëœ¬ê³µ]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-IF-O", score: -1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[1ë£¨ìˆ˜]",  detail: "[ëœ¬ê³µ]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-IF-O", score: -1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[2ë£¨ìˆ˜]",  detail: "[ëœ¬ê³µ]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-IF-O", score: -1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[3ë£¨ìˆ˜]",  detail: "[ëœ¬ê³µ]", result: "[íƒ€ì ì•„ì›ƒ]" } },
  { code: "B-IF-O", score: -1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[ìœ ê²©ìˆ˜]", detail: "[ëœ¬ê³µ]", result: "[íƒ€ì ì•„ì›ƒ]" } },

  { code: "B-IF-S", score: 0, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[íˆ¬ìˆ˜]",   detail: "[ëœ¬ê³µ]", result: "[ì¶œë£¨]" } },
  { code: "B-IF-S", score: 0, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[í¬ìˆ˜]",   detail: "[ëœ¬ê³µ]", result: "[ì¶œë£¨]" } },
  { code: "B-IF-S", score: 0, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[1ë£¨ìˆ˜]",  detail: "[ëœ¬ê³µ]", result: "[ì¶œë£¨]" } },
  { code: "B-IF-S", score: 0, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[2ë£¨ìˆ˜]",  detail: "[ëœ¬ê³µ]", result: "[ì¶œë£¨]" } },
  { code: "B-IF-S", score: 0, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[3ë£¨ìˆ˜]",  detail: "[ëœ¬ê³µ]", result: "[ì¶œë£¨]" } },
  { code: "B-IF-S", score: 0, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[ì•„ì›ƒì„±]", dir1: "[ìœ ê²©ìˆ˜]", detail: "[ëœ¬ê³µ]", result: "[ì¶œë£¨]" } },

  { code: "B-IF-S-T", score: 0.5,when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[í…ì‚¬ìŠ¤íˆíŠ¸ì„±]", detail: "[ëœ¬ê³µ]", result: "[ì¶œë£¨]" } },

  { code: "B-OF-SF", score: 0.5, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[í¬ìƒíƒ€/íƒ€ì ì„±]", detail: "[ëœ¬ê³µ]" } },

  { code: "B-OF-O", score: 0, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ì¢Œìµìˆ˜]", type: "[ì•„ì›ƒì„±]", detail: "[ëœ¬ê³µ]" } },
  { code: "B-OF-O", score: 0, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ì¤‘ê²¬ìˆ˜]", type: "[ì•„ì›ƒì„±]", detail: "[ëœ¬ê³µ]" } },
  { code: "B-OF-O", score: 0, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ìš°ìµìˆ˜]", type: "[ì•„ì›ƒì„±]", detail: "[ëœ¬ê³µ]" } },

  { code: "B-OF-S", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ì¢Œìµìˆ˜]", type: "[1ë£¨íƒ€ì„±]" } },
  { code: "B-OF-S", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ì¤‘ê²¬ìˆ˜]", type: "[1ë£¨íƒ€ì„±]" } },
  { code: "B-OF-S", score: 1, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ìš°ìµìˆ˜]", type: "[1ë£¨íƒ€ì„±]" } },

  { code: "B-OF-D", score: 2, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ì¢Œìµìˆ˜]", type: "[2ë£¨íƒ€ì„±]" } },
  { code: "B-OF-D", score: 2, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ì¤‘ê²¬ìˆ˜]", type: "[2ë£¨íƒ€ì„±]" } },
  { code: "B-OF-D", score: 2, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ìš°ìµìˆ˜]", type: "[2ë£¨íƒ€ì„±]" } },

  { code: "B-OF-T", score: 3, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ì¢Œìµìˆ˜]", type: "[3ë£¨íƒ€ì„±]" } },
  { code: "B-OF-T", score: 3, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ì¤‘ê²¬ìˆ˜]", type: "[3ë£¨íƒ€ì„±]" } },
  { code: "B-OF-T", score: 3, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", dir1: "[ìš°ìµìˆ˜]", type: "[3ë£¨íƒ€ì„±]" } },

  { code: "B-HR", score: 4, when: { event: "[íƒ€ê²© ì´ë²¤íŠ¸]", type: "[í™ˆëŸ°ì„±]" } }
];

/* ============== ìƒíƒœ ============== */
let starterKeys = ["1","2","3","4","5","6","7","8","9"];
let benchKeys   = ["q","w","e","r","t"];
let lineupMap = {};
let lineupApplied = false;
let logSeq = 0;
let scheduleNameState = "";

let playHistoryMap = {};
let lastInning = "";

const steps = [
  { name: "ì´ë‹ ì„ íƒ",   options: ["[1íšŒ]", "[2íšŒ]", "[3íšŒ]", "[4íšŒ]", "[5íšŒ]", "[6íšŒ]", "[7íšŒ]", "[8íšŒ]", "[9íšŒ]"] },
  { name: "íƒ€ìˆœ ì„ íƒ",   options: ["[1ë²ˆ]", "[2ë²ˆ]", "[3ë²ˆ]", "[4ë²ˆ]", "[5ë²ˆ]", "[6ë²ˆ]", "[7ë²ˆ]", "[8ë²ˆ]", "[9ë²ˆ]"] },
  { name: "ì„ ìˆ˜ ì„ íƒ",   options: [] },
  { name: "ì´ë²¤íŠ¸ ì„ íƒ", options: ["[íƒ€ê²© ì´ë²¤íŠ¸]", "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]", "[ì£¼ë£¨ ì´ë²¤íŠ¸]"] },
  { name: "íƒ€êµ¬ ë°©í–¥1",  options: ["[íˆ¬ìˆ˜]", "[í¬ìˆ˜]", "[1ë£¨ìˆ˜]", "[2ë£¨ìˆ˜]", "[3ë£¨ìˆ˜]", "[ìœ ê²©ìˆ˜]", "[ì¢Œìµìˆ˜]", "[ì¤‘ê²¬ìˆ˜]", "[ìš°ìµìˆ˜]"] },
  { name: "íƒ€êµ¬ ë°©í–¥2",  options: ["[ì•]", "[ë’¤]", "[ì„ ìƒ]", "[ì˜†]"] },
  { name: "íƒ€êµ¬ ì„±ê²©",   options: [] },
  { name: "íƒ€êµ¬ ì¢…ë¥˜",   options: [] },
  { name: "íƒ€ê²© ê²°ê³¼",   options: [] }
];

let currentStep = 0;
let currentValues = [];
let eventType = "";

/* ====== ìë™ì €ì¥ ====== */
const LS_PREFIX = "eagles_v37_";
const LS_KEYS = { lineup: LS_PREFIX + "lineup", table : LS_PREFIX + "table", state : LS_PREFIX + "state" };
let saveTimer = null;
function scheduleSave(){ clearTimeout(saveTimer); saveTimer = setTimeout(saveAll, 250); }
function saveAll(){
  try{
    localStorage.setItem(LS_KEYS.lineup, JSON.stringify({ lineupMap, lineupApplied, starterKeys, benchKeys, scheduleNameState }));
    localStorage.setItem(LS_KEYS.table , JSON.stringify({ logSeq, rows: serializeTable() }));
    localStorage.setItem(LS_KEYS.state , JSON.stringify({ currentStep, currentValues, eventType, stepsOptions3: steps[2].options, playHistoryMap, lastInning }));
  }catch(e){ console.warn("ìë™ì €ì¥ ì‹¤íŒ¨:", e); }
}
function loadAll(){
  try{
    const line = JSON.parse(localStorage.getItem(LS_KEYS.lineup) || "null");
    const table = JSON.parse(localStorage.getItem(LS_KEYS.table)  || "null");
    const state = JSON.parse(localStorage.getItem(LS_KEYS.state)  || "null");

    if (line && line.lineupMap) {
      lineupMap = line.lineupMap || {};
      lineupApplied = !!line.lineupApplied;
      scheduleNameState = line.scheduleNameState || "";
      const scheduleInput = document.getElementById("scheduleName");
      if (scheduleInput) scheduleInput.value = scheduleNameState;

      const opts = [];
      starterKeys.forEach(k => { if (lineupMap[k]) opts.push({ key: k, label: lineupMap[k] }); });
      benchKeys.forEach(k   => { if (lineupMap[k]) opts.push({ key: k, label: lineupMap[k] }); });
      steps[2].options = opts;

      document.getElementById("lineupInput").style.display = lineupApplied ? "none" : "block";
      renderLineupSummary();
      updateScheduleBadge();
    } else {
      document.getElementById("lineupInput").style.display = "block";
      lineupApplied = false;
      renderLineupSummary();
      updateScheduleBadge();
    }

    if (table && Array.isArray(table.rows)) {
      logSeq = table.logSeq || table.rows.length;
      renderTableFrom(table.rows);
    }

    if (state) {
      currentStep   = state.currentStep || 0;
      currentValues = Array.isArray(state.currentValues) ? state.currentValues : [];
      eventType     = state.eventType || "";
      if (Array.isArray(state.stepsOptions3)) steps[2].options = state.stepsOptions3;
      playHistoryMap = state.playHistoryMap || {};
      lastInning = state.lastInning || "";
    }

    updateLegend(); updateCurrentInputLine(); updateStepProgress(); updateInningTag();
    renderPlateAppearanceAvg_Offense(); // ì´ˆê¸° ë Œë”
    renderAdjSummary();                 // ì´ˆê¸° ë³´ì • ìš”ì•½
    renderLineupSummary();              // ì´ˆê¸° ì‹¤ì‹œê°„ ì ìˆ˜ ë°˜ì˜
  }catch(e){
    console.warn("ìë™ë³µêµ¬ ì‹¤íŒ¨:", e);
  }
}
function clearAllStorage(){ Object.values(LS_KEYS).forEach(k => localStorage.removeItem(k)); }

/* ====== ìœ í‹¸ ====== */
function stripBrackets(str) { return str ? str.replace(/\[|\]/g, '') : ''; }
function isTypingInEditable(e){
  const el = e.target;
  return el && (
    el.tagName === 'INPUT' ||
    el.tagName === 'TEXTAREA' ||
    el.isContentEditable === true
  );
}
/* ì†Œìˆ˜ì  2ìë¦¬ + ë¶€í˜¸ + ë¶€í˜¸ë³„ ìƒ‰ìƒ(span) */
function fmt3(n){
  if (!Number.isFinite(n)) return "-";
  const txt = (n>=0?"+":"") + n.toFixed(2);
  const cls = n>0 ? "pos" : (n<0 ? "neg" : "zero");
  return `<span class="num ${cls}">${txt}</span>`;
}

/* ====== ì¶•ì•½/ì½”ë“œ/ê¸°ë¡ ====== */
function buildContextFrom(vals){
  const ctx = { event: vals[3] || "-", dir1: vals[4] || "-", dir2: vals[5] || "-", type: "-", detail: "-", result: "-" };
  if (ctx.event === "[íƒ€ê²© ì´ë²¤íŠ¸]") {
    ctx.type   = vals[6] || "-";
    ctx.detail = vals[7] || "-";
    ctx.result = vals[8] || "-";
  } else if (ctx.event === "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]") {
    ctx.type   = vals[7] || "-";
    ctx.result = vals[8] || "-";
  } else if (ctx.event === "[ì£¼ë£¨ ì´ë²¤íŠ¸]") {
    ctx.type   = vals[6] || "-";
    ctx.result = vals[7] || "-";
  }
  return ctx;
}
function ruleMatches(ctx, rule){
  const w = rule.when || {};
  if (w.event  && w.event  !== ctx.event)  return false;
  if (w.dir1   && w.dir1   !== ctx.dir1)   return false;
  if (w.dir2   && w.dir2   !== ctx.dir2)   return false;
  if (w.type   && w.type   !== ctx.type)   return false;
  if (w.detail && w.detail !== ctx.detail) return false;
  if (w.result && w.result !== ctx.result) return false;
  return true;
}
function getCodeAndScore(vals) {
  const ctx = buildContextFrom(vals);
  const RULES = window.CODE_RULES || [];
  for (const r of RULES) { if (ruleMatches(ctx, r)) return { code: r.code, score: r.score }; }
  return { code: "", score: "" };
}
function hitLabel(t){
  if (t === "1ë£¨íƒ€ì„±" || t === "ë‚´ì•¼ì•ˆíƒ€ì„±") return " (ì•ˆíƒ€ì„±)";
  if (t === "2ë£¨íƒ€ì„±") return " (2ë£¨íƒ€ì„±)";
  if (t === "3ë£¨íƒ€ì„±") return " (3ë£¨íƒ€ì„±)";
  return "";
}
function buildRecord(vals) {
  const ev   = stripBrackets(vals[3] || "");
  const dir1 = stripBrackets(vals[4] || "");
  const dir2 = stripBrackets(vals[5] || "");
  const type = stripBrackets(vals[6] || "");
  const det  = stripBrackets(vals[7] || "");
  const res  = stripBrackets(vals[8] || "");

  const head = [dir1, (dir2 && dir2 !== "-") ? dir2 : ""].filter(Boolean).join(" ");
  const posPrefix = dir1 ? (dir1 + " ") : "";

  if (ev === "ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸") {
    const t = stripBrackets(vals[7] || "");
    const r = stripBrackets(vals[8] || "");
    if (t === "ì‚¼ì§„") return (r || "").includes("ì¶œë£¨") ? "ì‚¼ì§„ (ë‚«ì•„ì›ƒ ì¶œë£¨)" : "ì‚¼ì§„";
    if (t === "ë³¼ë„·") return "ë³¼ë„·";
    if (t === "ì‚¬êµ¬") return "ì‚¬êµ¬";
    return "ê¸°íƒ€";
  }
if (ev === "ì£¼ë£¨ ì´ë²¤íŠ¸") {
    const r7 = stripBrackets(vals[7] || "");
    if (r7 === "2ë£¨ ë„ë£¨ Q") return "2ë£¨ ë„ë£¨ (2êµ¬ ì´ë‚´)";
    return r7 || stripBrackets(vals[8] || "") || "-";
}
  if (det === "ë•…ë³¼" && res === "ì„ í–‰ì£¼ì ì•„ì›ƒ") return `${posPrefix}ë•…ë³¼ë¡œ ì„ í–‰ì£¼ì ì•„ì›ƒ`.trim();
  if (type === "ë³‘ì‚´íƒ€ì„±" && det === "ë•…ë³¼" && res === "ë”ë¸” ì•„ì›ƒ") return `${posPrefix}ë•…ë³¼ë¡œ ë³‘ì‚´ ì•„ì›ƒ`.trim();
  if ((det === "ëœ¬ê³µ" || det === "ì§ì„ íƒ€") && res === "ì„ í–‰ì£¼ì ì•„ì›ƒ") {
    const kind = (det === "ëœ¬ê³µ" ? "í”Œë¼ì´" : "ì§ì„ íƒ€");
    const suffix = hitLabel(type);
    return head ? `${head} ${kind}ë¡œ ì„ í–‰ì£¼ì ì•„ì›ƒ${suffix}` : `${kind}ë¡œ ì„ í–‰ì£¼ì ì•„ì›ƒ${suffix}`;
  }
  if (type === "í¬ìƒíƒ€/íƒ€ì ì„±" && det === "ëœ¬ê³µ") return `${posPrefix}í¬ìƒ í”Œë¼ì´`.trim();
  if (type === "í¬ìƒíƒ€/íƒ€ì ì„±" && det === "ë•…ë³¼") {
    if (res === "íƒ€ì ì•„ì›ƒ") return `${posPrefix}ë•…ë³¼ ì•„ì›ƒ (íƒ€ì )`.trim();
    return `${posPrefix}ë•…ë³¼ (íƒ€ì )`.trim();
  }
  if (type === "í™ˆëŸ°ì„±") return head ? `${head} í™ˆëŸ°` : "í™ˆëŸ°";
  if ((res && res.includes("ì¶œë£¨")) && (type === "ì•„ì›ƒì„±" || type === "ë³‘ì‚´íƒ€ì„±")) {
    const kind = (det === "ëœ¬ê³µ" ? "í”Œë¼ì´" : det);
    return head ? `${head} ${kind} ì‹¤ì±…ìœ¼ë¡œ ì¶œë£¨` : `${kind} ì‹¤ì±…ìœ¼ë¡œ ì¶œë£¨`;
  }
  if (res && res.includes("ì¶œë£¨")) {
    const mapType = { "1ë£¨íƒ€ì„±":"1ë£¨íƒ€", "2ë£¨íƒ€ì„±":"2ë£¨íƒ€", "3ë£¨íƒ€ì„±":"3ë£¨íƒ€", "ë‚´ì•¼ì•ˆíƒ€ì„±":"ë‚´ì•¼ì•ˆíƒ€", "í…ì‚¬ìŠ¤íˆíŠ¸ì„±":"í…ì‚¬ìŠ¤íˆíŠ¸" };
    const t = mapType[type] || type;
    return head ? `${head} ${t}` : t;
  }
  if (res === "íƒ€ì ì•„ì›ƒ" || res === "ë”ë¸” ì•„ì›ƒ") {
    const kind = (det === "ëœ¬ê³µ" ? "í”Œë¼ì´" : det);
    const base = head ? `${head} ${kind} ${res === "ë”ë¸” ì•„ì›ƒ" ? "ë”ë¸” ì•„ì›ƒ" : "ì•„ì›ƒ"}` : `${kind} ${res === "ë”ë¸” ì•„ì›ƒ" ? "ë”ë¸” ì•„ì›ƒ" : "ì•„ì›ƒ"}`;
    const suffix = (res === "íƒ€ì ì•„ì›ƒ") ? hitLabel(type) : "";
    return base + suffix;
  }
  return "-";
}

/* ====== íˆìŠ¤í† ë¦¬(ë¼ì¸ì—… ë¯¸ë‹ˆí‘œì‹œìš©) ====== */
function makeShortPlay(vals){
  const ev = stripBrackets(vals[3] || "");
  if (ev === "ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸") {
    const t = stripBrackets(vals[7] || ""); const r = stripBrackets(vals[8] || "");
    if (t === "ì‚¼ì§„") return (r || "").includes("ì¶œë£¨") ? "ì‚¼ì¶œ" : "ì‚¼ì§„";
    if (t === "ë³¼ë„·") return "ë³¼ë„·";
    if (t === "ì‚¬êµ¬") return "ì‚¬êµ¬";
    return "ê¸°íƒ€";
  }
  if (ev !== "íƒ€ê²© ì´ë²¤íŠ¸") return "";

  const dir1 = stripBrackets(vals[4] || "");
  const dir2 = stripBrackets(vals[5] || "");
  const type = stripBrackets(vals[6] || "");
  const det  = stripBrackets(vals[7] || "");
  const res  = stripBrackets(vals[8] || "");

  const D1 = { "ì¢Œìµìˆ˜":"ì¢Œ", "ì¤‘ê²¬ìˆ˜":"ì¤‘", "ìš°ìµìˆ˜":"ìš°", "ìœ ê²©ìˆ˜":"ìœ ", "3ë£¨ìˆ˜":"3", "2ë£¨ìˆ˜":"2", "1ë£¨ìˆ˜":"1", "íˆ¬ìˆ˜":"íˆ¬", "í¬ìˆ˜":"í¬" };
  const D2 = { "ë’¤":"ì›”", "ì„ ìƒ":"ì„ ", "ì˜†":"ì¤‘", "ì•":"" };
  const OUT = { "ë•…ë³¼":"ë•…", "ëœ¬ê³µ":"í”Œ", "ì§ì„ íƒ€":"ì§" };

  const d1 = D1[dir1] || "";
  const d2 = (dir2 in D2) ? D2[dir2] : "";

  if ((res || "").includes("ì¶œë£¨")){
    if (type === "í™ˆëŸ°ì„±") return "í™ˆëŸ°";
    if (type === "2ë£¨íƒ€ì„±") return `${d1}${d2}2`;
    if (type === "3ë£¨íƒ€ì„±") return `${d1}${d2}3`;
    if (["1ë£¨íƒ€ì„±","ë‚´ì•¼ì•ˆíƒ€ì„±","í…ì‚¬ìŠ¤íˆíŠ¸ì„±"].includes(type)) return `${d1}${d2}ì•ˆ`;
    if (type === "ì•„ì›ƒì„±" || type === "ë³‘ì‚´íƒ€ì„±") { const o = OUT[det] || ""; return `${d1}${d2}${o}ì‹¤`; }
  }
  if (res === "íƒ€ì ì•„ì›ƒ" || res === "ë”ë¸” ì•„ì›ƒ" || res === "ì„ í–‰ì£¼ì ì•„ì›ƒ"){
    const o = OUT[det] || ""; return `${d1}${d2}${o}`;
  }
  if (type === "í¬ìƒíƒ€/íƒ€ì ì„±" && det === "ëœ¬ê³µ") return `${d1}${d2}í¬í”Œ`;
  return "";
}
function pushPlayHistory(playerName, inning, shortTxt){
  if (!playerName || !shortTxt) return;
  if (!playHistoryMap[playerName]) playHistoryMap[playerName] = [];
  playHistoryMap[playerName].push({ inning, short: shortTxt });
}

/* ====== ë¼ì´ë¸Œ ê³µê²©ì ìˆ˜ ì§‘ê³„ ====== */
function computeLiveScoresByPlayer(){
  const tbody = document.querySelector('#logTable tbody');
  const map = {};
  for (const tr of tbody.rows){
    const player = (tr.cells[4]?.textContent || '').trim();
    const scoreStr = (tr.cells[13]?.textContent || '').trim();
    const s = parseFloat(scoreStr);
    if (!player) continue;
    if (!map[player]) map[player] = 0;
    if (Number.isFinite(s)) map[player] += s;
  }
  return map;
}

/* ====== íƒ€ì„ ë³´ì •ì ìˆ˜(ê³µê²©) ======
 * íŒ€ í‰ê·  = (ì ìˆ˜ í•©ê³„) / (PA)
 * PA = ì´ë²¤íŠ¸ê°€ [íƒ€ê²© ì´ë²¤íŠ¸] ë˜ëŠ” [ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸] ì¸ í–‰ì˜ ê°œìˆ˜
 * í‘œ ì»¬ëŸ¼ ì¸ë±ìŠ¤:
 *   0 chk, 1 #, 2 ì´ë‹, 3 íƒ€ìˆœ, 4 ì„ ìˆ˜, 5 ì´ë²¤íŠ¸, ..., 13 ì ìˆ˜
 */
function computePlateAppearanceAvg_Offense(){
  const tbody = document.querySelector('#logTable tbody');
  let pa = 0;
  let total = 0;

  for (const tr of tbody.rows){
    const eventTxt = (tr.cells[5]?.textContent || '').trim();
    const scoreStr = (tr.cells[13]?.textContent || '').trim();
    const score    = parseFloat(scoreStr);

    if (eventTxt === "[íƒ€ê²© ì´ë²¤íŠ¸]" || eventTxt === "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]") {
      pa += 1;
    }
    if (Number.isFinite(score)) total += score;
  }
  return { total, pa, avg: (pa > 0 ? Math.max(0, total / pa) : NaN) };
}
function renderPlateAppearanceAvg_Offense(){
  const box = document.getElementById('paAdjBody');
  if (!box) return;
  const { total, pa, avg } = computePlateAppearanceAvg_Offense();
  const fmt = (n)=> Number.isFinite(n) ? n.toFixed(2) : '-';
  box.innerHTML = `
    <table>
      <tbody>
        <tr><td style="text-align:left">ì ìˆ˜ í•©ê³„</td><td>${fmt(total)}</td></tr>
        <tr><td style="text-align:left">íƒ€ì„ìˆ˜</td><td>${pa}</td></tr>
        <tr><td style="text-align:left">íƒ€ì„ ë³´ì •ì ìˆ˜ (íƒ€ì„ë‹¹)</td><td>${fmt(avg)}</td></tr>
      </tbody>
    </table>`;
}

/* ====== ë³´ì • ëŒ€ìƒì íŒë³„ + ìš”ì•½ ë Œë” ====== */
function renderAdjSummary(){
  const box = document.getElementById('paAdjSummary');
  if (!box) return;

  // íŒ€ í‰ê· 
  const { avg: teamAvg } = computePlateAppearanceAvg_Offense();

  // ì§‘ê³„ ë§µ
  const tbody = document.querySelector('#logTable tbody');
  const slotPA = {};                              // slot: ì´ PA
  const playerPA = {};                            // player: ì´ PA
  const playerSlotPA = {};                        // player -> {slot: PA}
  // PAë¡œ ì¸ì •ë˜ëŠ” ì´ë²¤íŠ¸ë§Œ ì¹´ìš´íŠ¸
  for (const tr of tbody.rows){
    const eventTxt = (tr.cells[5]?.textContent || '').trim();
    if (!(eventTxt === "[íƒ€ê²© ì´ë²¤íŠ¸]" || eventTxt === "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]")) continue;

    const slotRaw = (tr.cells[3]?.textContent || '').trim(); // [1ë²ˆ] í˜•íƒœ
    const slot = stripBrackets(slotRaw).replace("ë²ˆ","").trim();
    const player = (tr.cells[4]?.textContent || '').trim();

    if (slot) slotPA[slot] = (slotPA[slot]||0) + 1;
    if (player){
      playerPA[player] = (playerPA[player]||0) + 1;
      if (!playerSlotPA[player]) playerSlotPA[player] = {};
      playerSlotPA[player][slot] = (playerSlotPA[player][slot]||0) + 1;
    }
  }

  // ëŒ€ìƒì ì„ ë³„: PAê°€ 1 ë˜ëŠ” 2ì´ê³ , ìì‹ ì´ ë“¤ì–´ê°„ ëª¨ë“  íƒ€ìˆœì—ì„œ í’€ì»¤ë²„ê°€ ì•„ë‹˜
  const targets = [];
  Object.keys(playerPA).forEach(p=>{
    const pa = playerPA[p];
    if (pa !== 1 && pa !== 2) return;

    const slots = Object.keys(playerSlotPA[p] || {});
    // ëª¨ë“  ì°¸ì—¬ íƒ€ìˆœì—ì„œ "í•´ë‹¹ ìŠ¬ë¡¯ì˜ ì „ì²´ PAë¥¼ ë³¸ì¸ì´ ë‹¤ ì†Œí™”"í–ˆëŠ”ì§€ í™•ì¸
    const isFullEverySlot = slots.length > 0 && slots.every(s => (playerSlotPA[p][s] === (slotPA[s]||0)));
    if (isFullEverySlot) return; // í’€ì¶œì „ â†’ ì œì™¸

    // ë³´ì • ê°€ì¤‘ì¹˜: 3-PA
    const miss = 3 - pa;
    const delta = Number.isFinite(teamAvg) ? teamAvg * miss : NaN;
    targets.push({ player:p, pa, miss, delta });
  });

  // ë Œë”
  if (targets.length === 0){
    box.innerHTML = `<h5>ë³´ì • ëŒ€ìƒì</h5><div>ë³´ì • ëŒ€ìƒì ì—†ìŒ</div>`;
    return;
  }
  const sumDelta = targets.reduce((a,b)=> a + (Number.isFinite(b.delta)? b.delta : 0), 0);
  const li = targets.map(t=>{
    const mult = t.pa===1 ? "ë³´ì •Ã—2" : "ë³´ì •Ã—1";
    return `<li>${t.player} (PA ${t.pa})  ${mult}  â†’ ${fmt3(t.delta)}</li>`;
  }).join("");
  box.innerHTML = `
    <h5>ë³´ì • ëŒ€ìƒì</h5>
    <ul>${li}</ul>
  `;
}

/* ====== ì´ˆê¸°í™”/ë¼ì¸ì—…/ë°°ì§€ ====== */
window.onload = () => {
  const starterDiv = document.getElementById("starterInputs");
  for (let i = 0; i < 9; i++) starterDiv.innerHTML += `<input id="starter${i}" placeholder="${i+1}ë²ˆ">`;
  const benchDiv = document.getElementById("benchInputs");
  const benchKeys = ["q","w","e","r","t"];
  for (let i = 0; i < 5; i++) benchDiv.innerHTML += `<input id="bench${i}" placeholder="${benchKeys[i]}">`;

  document.getElementById("applyLineupBtn").addEventListener("click", applyLineup);
  document.getElementById("toggleEdit").addEventListener("click", ()=> setEditMode(!editMode));
  setSelectAllBehavior();
  bindResetAll();

  const scheduleInput = document.getElementById("scheduleName");
  scheduleInput.addEventListener('input', ()=>{ scheduleNameState = scheduleInput.value.trim(); updateScheduleBadge(); scheduleSave(); });

  loadAll();
};
function updateScheduleBadge(){
  const badge = document.getElementById('schedulePreview');
  const txt = (scheduleNameState||'').trim();
  if (txt){ badge.textContent = `ì¼ì •: ${txt}`; badge.style.display='inline-block'; }
  else { badge.textContent=''; badge.style.display='none'; }
}
function clearLineupInputs(){
  for (let i = 0; i < 9; i++) { const el = document.getElementById(`starter${i}`); if (el) el.value = ""; }
  for (let i = 0; i < 5; i++) { const el = document.getElementById(`bench${i}`);   if (el) el.value = ""; }
}
function applyLineup() {
  const starters = starterKeys.map((k, i) => document.getElementById("starter"+i).value).filter(Boolean);
  const bench    = benchKeys.map((k, i) => document.getElementById("bench"+i).value).filter(Boolean);

  const scheduleInput = document.getElementById("scheduleName");
  scheduleNameState = (scheduleInput && scheduleInput.value.trim()) || "";

  lineupMap = {};
  starters.forEach((name, i) => lineupMap[starterKeys[i]] = name);
  bench.forEach((name, i)    => lineupMap[benchKeys[i]]   = name);

  const opts = [];
  starterKeys.forEach(k => { if (lineupMap[k]) opts.push({ key: k, label: lineupMap[k] }); });
  benchKeys.forEach(k   => { if (lineupMap[k]) opts.push({ key: k, label: lineupMap[k] }); });
  steps[2].options = opts;

  currentStep = 0; currentValues = []; eventType = ""; lineupApplied = true;

  updateLegend(); updateCurrentInputLine(); updateStepProgress();
  document.getElementById("lineupInput").style.display = "none";
  renderLineupSummary();
  updateScheduleBadge();
  scheduleSave();
}
function updateInningTag(){
  const tag = document.getElementById("currentInningTag");
  if (lastInning){
    tag.textContent = `ìµœê·¼ ì´ë‹: ${stripBrackets(lastInning)}`;
    tag.style.display = "inline-block";
  }else{
    tag.textContent = "";
    tag.style.display = "none";
  }
}
function renderLineupSummary() {
  const box = document.getElementById('lineupSummary');
  if (!box) return;

  // â¬‡ï¸ ì‹¤ì‹œê°„ ê³µê²©ì ìˆ˜ ì§‘ê³„
  const liveScores = computeLiveScoresByPlayer();

  function histString(name){
    const items = (playHistoryMap[name] || []).map(h => `${stripBrackets(h.inning)} ${h.short}`);
    return items.length ? `<span class="miniPlay">${items.join(", ")}</span>` : '';
  }

  function nameWithScore(name, keyLabel){
    const s = liveScores[name];
    const badge = (s !== undefined && Number.isFinite(s)) ? `<span class="liveScore">${fmt3(s)}</span>` : '';
    return `<div><span class="key">${keyLabel}</span> ${badge} ${name} ${histString(name)}</div>`;
  }

  const startersHtml = starterKeys
    .map(k => lineupMap[k] ? nameWithScore(lineupMap[k], k) : '')
    .join('') || '<div>-</div>';

  const benchHtml = benchKeys
    .map(k => lineupMap[k] ? nameWithScore(lineupMap[k], k) : '')
    .join('') || '<div>-</div>';

  document.getElementById('starterList').innerHTML = startersHtml;
  document.getElementById('benchList').innerHTML = benchHtml;
  box.style.display = lineupApplied ? 'block' : 'none';
  updateInningTag();
}

/* ====== í‚¤ ì…ë ¥(í¸ì§‘ ì¤‘ì—” ë‹¨ì¶•í‚¤ ë¬´ì‹œ) ====== */
document.addEventListener("keydown", (e) => {
  if (isTypingInEditable(e)) return;
  if (!lineupApplied) return;

  if (e.key === "Escape") {
    currentStep = 0; currentValues = []; eventType = "";
    updateLegend(); updateCurrentInputLine(); updateStepProgress();
    scheduleSave();
    return;
  }

  const step = steps[currentStep];
  const options = step.options;

  // ì„ ìˆ˜ ì„ íƒ
  if (currentStep === 2) {
    const k = normalizePlayerKey(e.key);
    if (lineupMap[k]) {
      currentValues.push(lineupMap[k]);
      currentStep++;
      updateLegend(); updateCurrentInputLine(); updateStepProgress();
      scheduleSave();
      return;
    }
  }

  // ì„±ê²© íŠ¹ìˆ˜í‚¤
  if (currentStep === 6) {
    const normalizedKey = (e.key === "\\" || e.key === "`") ? "â‚©" : e.key;
    const match = (options||[]).find(o => typeof o === "object" && o.key === normalizedKey);
    if (match) {
      currentValues.push(match.label);
      currentStep++;
      updateLegend(); updateCurrentInputLine(); updateStepProgress();
      scheduleSave();
      return;
    }
  }

  // ì´ë²¤íŠ¸ ì„ íƒ
  if (currentStep === 3 && e.key >= "1" && e.key <= "3") {
    const selected = step.options[parseInt(e.key) - 1];
    currentValues.push(selected);
    eventType = selected;

    if (selected === "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]") {
      currentValues.push("-", "-", "-");
      steps[7].options = [
        { key: "â‚©", label: "[ì‚¼ì§„]", color: "red" },
        { key: "1", label: "[ë³¼ë„·]", color: "green" },
        { key: "2", label: "[ì‚¬êµ¬]", color: "green" },
        { key: "3", label: "[ê¸°íƒ€]", color: "yellow" }
      ];
      currentStep = 7;

    } else if (selected === "[ì£¼ë£¨ ì´ë²¤íŠ¸]") {
      currentValues.push("-", "-");
      steps[6].options = ["[ë„ë£¨]", "[ì§„ë£¨]", "[ì•„ì›ƒ]", "[ì§„ë£¨ ê¸°íšŒ ë†“ì¹¨]", "[ì£¼ë£¨ ì‘ì „]"];
      currentStep = 6;

    } else {
      steps[4].options = ["[íˆ¬ìˆ˜]", "[í¬ìˆ˜]", "[1ë£¨ìˆ˜]", "[2ë£¨ìˆ˜]", "[3ë£¨ìˆ˜]", "[ìœ ê²©ìˆ˜]", "[ì¢Œìµìˆ˜]", "[ì¤‘ê²¬ìˆ˜]", "[ìš°ìµìˆ˜]"];
      steps[5].options = ["[ì•]", "[ë’¤]", "[ì„ ìƒ]", "[ì˜†]"];
      steps[6].options = [
        { key: "â‚©", label: "[ì•„ì›ƒì„±]",      color: "red"   },
        { key: "1", label: "[1ë£¨íƒ€ì„±]",     color: "green" },
        { key: "2", label: "[2ë£¨íƒ€ì„±]",     color: "green" },
        { key: "3", label: "[3ë£¨íƒ€ì„±]",     color: "green" },
        { key: "4", label: "[í™ˆëŸ°ì„±]",      color: "green" },
        { key: "5", label: "[ë‚´ì•¼ì•ˆíƒ€ì„±]",   color: "green" },
        { key: "6", label: "[í…ì‚¬ìŠ¤íˆíŠ¸ì„±]", color: "green" },
        { key: "7", label: "[ë³‘ì‚´íƒ€ì„±]",     color: "red"   },
        { key: "8", label: "[í¬ìƒíƒ€/íƒ€ì ì„±]", color: "green" }
      ];
      steps[7].options = ["[ë•…ë³¼]", "[ì§ì„ íƒ€]", "[ëœ¬ê³µ]"];
      steps[8].options = [
        { key: "1", label: "[ì¶œë£¨]",         color: "green" },
        { key: "2", label: "[íƒ€ì ì•„ì›ƒ]",     color: "red"   },
        { key: "3", label: "[ì„ í–‰ì£¼ì ì•„ì›ƒ]", color: "red"   }
      ];
      currentStep++;
    }

    updateLegend(); updateCurrentInputLine(); updateStepProgress();
    scheduleSave();
    return;
  }

  // ì‚¼ì§„/ì‚¬ì‚¬êµ¬ - ì¢…ë¥˜
  if (eventType === "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]" && currentStep === 7) {
    const normalizedKey = (e.key === "\\" || e.key === "`") ? "â‚©" : e.key;
    const match = steps[7].options.find(o => o.key === normalizedKey);
    if (!match) return;
    currentValues.push(match.label);

    if (match.label === "[ë³¼ë„·]" || match.label === "[ì‚¬êµ¬]") {
      steps[8].options = [{ key: "1", label: "[ì¶œë£¨]", color: "green" }];
    } else if (match.label === "[ì‚¼ì§„]") {
      steps[8].options = [
        { key: "â‚©", label: "[ì•„ì›ƒ]", color: "red" },
        { key: "1", label: "[ì¶œë£¨]", color: "green" }
      ];
    } else {
      steps[8].options = [
        { key: "â‚©", label: "[ì•„ì›ƒ]", color: "red" },
        { key: "1", label: "[ì¶œë£¨]", color: "green" },
        { key: "2", label: "[ê¸°íƒ€]", color: "yellow" }
      ];
    }
    currentStep = 8;
    updateLegend(); updateCurrentInputLine(); updateStepProgress();
    scheduleSave();
    return;
  }

  // ì‚¼ì§„/ì‚¬ì‚¬êµ¬ - ê²°ê³¼ í›„ ì¢…ë£Œ
  if (eventType === "[ì‚¼ì§„/ì‚¬ì‚¬êµ¬ ì´ë²¤íŠ¸]" && currentStep === 8) {
    const normalizedKey = (e.key === "\\" || e.key === "`") ? "â‚©" : e.key;
    const match = steps[8].options.find(o => o.key === normalizedKey);
    if (match) {
      currentValues.push(match.label);
      currentStep++;
      if (currentStep === 9) writeRowAndReset();
      else { updateLegend(); updateCurrentInputLine(); updateStepProgress(); scheduleSave(); }
      return;
    }
  }

  // ì£¼ë£¨ ì´ë²¤íŠ¸
  if (eventType === "[ì£¼ë£¨ ì´ë²¤íŠ¸]" && currentStep === 6 && e.key >= "1" && e.key <= "5") {
    const selected = steps[6].options[parseInt(e.key) - 1];
    currentValues.push(selected);
    let types = [];
    if (selected === "[ë„ë£¨]") types = [
      { key: "1", label: "[2ë£¨ ë„ë£¨ Q]", color: "green" },
      { key: "2", label: "[2ë£¨ ë„ë£¨]", color: "green" },
      { key: "3", label: "[3ë£¨ ë„ë£¨]", color: "green" }
    ];
    if (selected === "[ì§„ë£¨]") types = [
      { key: "1", label: "[2ë£¨ ETB]", color: "green" },
      { key: "2", label: "[3ë£¨ ETB]", color: "green" },
      { key: "3", label: "[í™ˆ ETB]", color: "green" },
      { key: "4", label: "[í­íˆ¬ë¡œ ì§„ë£¨]", color: "yellow" },
      { key: "5", label: "[ì‹¤ì±…ìœ¼ë¡œ ì§„ë£¨]", color: "yellow" },
      { key: "6", label: "[ì§„ë£¨íƒ€ë¡œ ì§„ë£¨]", color: "yellow" }
    ];
    if (selected === "[ì•„ì›ƒ]") types = [
      { key: "1", label: "[ë„ë£¨ì/ì£¼ë£¨ì‚¬ (2ë£¨)]", color: "red" },
      { key: "2", label: "[ë„ë£¨ì/ì£¼ë£¨ì‚¬ (3ë£¨)]", color: "red" },
      { key: "3", label: "[ë„ë£¨ì/ì£¼ë£¨ì‚¬ (í™ˆ)]", color: "red" }
    ];
    if (selected === "[ì§„ë£¨ ê¸°íšŒ ë†“ì¹¨]") types = [
      { key: "1", label: "[ì§„ë£¨ ê¸°íšŒ ë†“ì¹¨ (2ë£¨/3ë£¨)]", color: "red" },
      { key: "2", label: "[ì§„ë£¨ ê¸°íšŒ ë†“ì¹¨ (í™ˆ)]", color: "red" },
      { key: "3", label: "[ë„ë£¨ ê¸°íšŒ ë†“ì¹¨]", color: "red" }
    ];
    if (selected === "[ì£¼ë£¨ ì‘ì „]") types = [
      { key: "1", label: "[ì£¼ë£¨ ì‘ì „ ì„±ê³µ]", color: "green" },
      { key: "2", label: "[ì£¼ë£¨ ì‘ì „ ì‹¤íŒ¨]", color: "red" }
    ];
    steps[7].options = types;
    currentStep++;
    updateLegend(); updateCurrentInputLine(); updateStepProgress();
    scheduleSave();
    return;
  }

// ê³µí†µ 1~9
if (e.key >= "1" && e.key <= "9") {
  const index = parseInt(e.key) - 1;
  if (options && options[index]) {
    const val = options[index];
    currentValues.push(typeof val === "object" ? val.label : val);
    currentStep++;

    // ğŸ”§ ì¶”ê°€: íƒ€ê²© ì´ë²¤íŠ¸ì—ì„œ 'ë³‘ì‚´íƒ€ì„±' + 'ë•…ë³¼'ì´ë©´ ê²°ê³¼ ë‹¨ê³„(8ë‹¨ê³„)ì— [ë”ë¸” ì•„ì›ƒ] ì˜µì…˜ì„ ë…¸ì¶œ
    //  - currentValues[6] : ì„±ê²©
    //  - currentValues[7] : ì¢…ë¥˜
    if (eventType === "[íƒ€ê²© ì´ë²¤íŠ¸]" && currentStep === 8) {
      const t = currentValues[6];  // ì„±ê²©
      const d = currentValues[7];  // ì¢…ë¥˜
      if (t === "[ë³‘ì‚´íƒ€ì„±]" && d === "[ë•…ë³¼]") {
        steps[8].options = [
          { key: "1", label: "[ì¶œë£¨]",         color: "green" },
          { key: "2", label: "[íƒ€ì ì•„ì›ƒ]",     color: "red"   },
          { key: "3", label: "[ì„ í–‰ì£¼ì ì•„ì›ƒ]", color: "red"   },
          { key: "4", label: "[ë”ë¸” ì•„ì›ƒ]",     color: "red"   }
        ];
      }
    }

    if (eventType === "[ì£¼ë£¨ ì´ë²¤íŠ¸]" && currentStep === 8) { 
      writeRowAndReset(); 
      return; 
    }
    if (currentStep === 9) { 
      writeRowAndReset(); 
      return; 
    }

    updateLegend(); 
    updateCurrentInputLine(); 
    updateStepProgress();
    scheduleSave();
  }
}
  if (e.key === "Backspace") {
    if (currentStep > 0) {
      currentStep--; currentValues.pop();
      updateLegend(); updateCurrentInputLine(); updateStepProgress();
      scheduleSave();
    }
    e.preventDefault();
  }
});
function normalizePlayerKey(key) {
  if (!key) return key;
  const map = { "ã…‚":"q", "ã…ˆ":"w", "ã„·":"e", "ã„±":"r", "ã……":"t" };
  if (key.length === 1) return (map[key] || key).toLowerCase();
  return key;
}

/* ====== í–‰ ì“°ê¸° & ë¦¬ì…‹ ====== */
function writeRowAndReset() {
  const { code, score } = getCodeAndScore(currentValues);
  const tbody = document.getElementById("logTable").tBodies[0];
  const row = tbody.insertRow(0);

  row.insertCell(0).innerHTML = '<input type="checkbox" class="rowSel">';
  row.insertCell(1).innerText = String(++logSeq);

  for (let i = 0; i < steps.length; i++) row.insertCell(i + 2).innerText = currentValues[i] || "-";

  const rec = buildRecord(currentValues);
  row.insertCell(steps.length + 2).innerText = rec;
  row.insertCell(steps.length + 3).innerText = code || "-";
  row.insertCell(steps.length + 4).innerText = (score !== "" ? score : "-");

  const playerName = currentValues[2];
  const mini = makeShortPlay(currentValues);
  const inning = currentValues[0] || "";
  if (playerName && mini) pushPlayHistory(playerName, inning, mini);
  lastInning = inning || lastInning;
  renderLineupSummary();

  currentStep = 0; currentValues = []; eventType = "";
  updateLegend(); updateCurrentInputLine(); updateStepProgress();
  scheduleSave();

  // â¬‡ï¸ íƒ€ì„ ë³´ì •ì ìˆ˜ & ë³´ì • ìš”ì•½ & ë¼ì¸ì—… ì ìˆ˜ ë°°ì§€ ê°±ì‹ 
  renderPlateAppearanceAvg_Offense();
  renderAdjSummary();
  renderLineupSummary();
}

/* ====== í…Œì´ë¸” ì§ë ¬í™”/ë³µêµ¬ ====== */
function serializeTable(){
  const tbody = document.querySelector("#logTable tbody");
  const rows = [];
  Array.from(tbody.rows).forEach(tr => {
    const cells = Array.from(tr.cells).map(td => td.textContent);
    rows.push({
      perf: cells[1],
      values: cells.slice(2, 2 + steps.length),
      record: cells[2 + steps.length],
      code:   cells[3 + steps.length],
      score:  cells[4 + steps.length]
    });
  });
  return rows;
}
function renderTableFrom(rows){
  const tbody = document.querySelector("#logTable tbody");
  tbody.innerHTML = "";
  (rows || []).forEach(r => {
    const tr = tbody.insertRow(-1);
    tr.insertCell(0).innerHTML = '<input type="checkbox" class="rowSel">';
    tr.insertCell(1).innerText = r.perf || "";
    (r.values || []).forEach(v => tr.insertCell(-1).innerText = v || "-");
    tr.insertCell(-1).innerText = r.record || "";
    tr.insertCell(-1).innerText = r.code   || "-";
    tr.insertCell(-1).innerText = (r.score !== undefined && r.score !== null) ? r.score : "-";
  });

  // íˆìŠ¤í† ë¦¬ ì¬êµ¬ì„±
  playHistoryMap = {};
  lastInning = "";
  (rows || []).forEach(r => {
    const vals = r.values || [];
    const name = vals[2];
    const mini = makeShortPlay(vals);
    const inn  = vals[0] || "";
    if (name && mini) pushPlayHistory(name, inn, mini);
    if (!lastInning && vals[0]) lastInning = vals[0];
  });
  renderLineupSummary();

  // â¬‡ï¸ ì ìˆ˜/ë³´ì • ì „ë¶€ ê°±ì‹ 
  renderPlateAppearanceAvg_Offense();
  renderAdjSummary();
  renderLineupSummary();
}

/* ====== í¸ì§‘ ëª¨ë“œ ====== */
let editMode = false;
function setEditMode(on){
  editMode = !!on;
  const table = document.getElementById('logTable');
  table.classList.toggle('editing', editMode);
  const btn = document.getElementById('toggleEdit');
  btn.textContent = `ë¡œê·¸ ìˆ˜ì •: ${editMode?'ON':'OFF'}`;

  const editableStart = 2;
  const editableEnd   = 13; // ì´ë‹(2) ~ ì ìˆ˜(13)
  const rows = table.tBodies[0].rows;
  for (const tr of rows){
    for (let c=editableStart; c<=editableEnd; c++){
      const td = tr.cells[c]; if(!td) continue;
      td.contentEditable = editMode ? 'true' : 'false';
      td.classList.toggle('ed', editMode);
    }
  }

  if(!editMode){
    scheduleSave();
    // â¬‡ï¸ í¸ì§‘ ì¢…ë£Œ ì‹œ ê°ì¢… ì§‘ê³„ ê°±ì‹ 
    renderPlateAppearanceAvg_Offense();
    renderAdjSummary();
    renderLineupSummary();
  }
}
// ...ê¸°ì¡´ ìŠ¤í¬ë¦½íŠ¸ ìœ„ì•„ë˜ ìƒëµ...

function copyCSVToClipboard(){
  // CSVë¡œ ì¶”ì¶œê³¼ 'ì™„ì „íˆ ê°™ì€ ë¡œì§' ì‚¬ìš©
  const csv = tableToCSV(); // ì„±ê³¼ê°ì²´ëª… í¬í•¨, ì¼ì •ëª… ì»¬ëŸ¼ í¬í•¨

  const btn = document.getElementById('copyCsv');
  const setLabel = (txt)=>{
    if(!btn) return;
    const original = btn.textContent;
    btn.textContent = txt;
    btn.disabled = true;
    setTimeout(()=>{ btn.textContent = original; btn.disabled = false; }, 1200);
  };

  // ì•ˆì „ì»¨í…ìŠ¤íŠ¸/ê¶Œí•œ ë¬¸ì œ ëŒ€ë¹„: navigator.clipboard â†’ ì‹¤íŒ¨ ì‹œ execCommand í´ë°±
  if (navigator.clipboard && navigator.clipboard.writeText) {
    navigator.clipboard.writeText(csv)
      .then(()=> setLabel('ë³µì‚¬ ì™„ë£Œ!'))
      .catch(()=>{
        fallbackCopyTextToClipboard(csv) ? setLabel('ë³µì‚¬ ì™„ë£Œ!') : setLabel('ë³µì‚¬ ì‹¤íŒ¨');
      });
  } else {
    fallbackCopyTextToClipboard(csv) ? setLabel('ë³µì‚¬ ì™„ë£Œ!') : setLabel('ë³µì‚¬ ì‹¤íŒ¨');
  }
}

function fallbackCopyTextToClipboard(text){
  try{
    const ta = document.createElement('textarea');
    ta.value = text;
    ta.style.position = 'fixed';
    ta.style.top = '-1000px';
    ta.style.left = '-1000px';
    ta.setAttribute('readonly','');
    document.body.appendChild(ta);
    ta.select();
    const ok = document.execCommand('copy');
    document.body.removeChild(ta);
    return ok;
  }catch(e){
    return false;
  }
}

/* ====== ì‚­ì œ/ì„ íƒ/CSV/ì´ˆê¸°í™” ====== */
function deleteSelectedRows() {
  const tbody = document.getElementById("logTable").getElementsByTagName("tbody")[0];
  const checked = Array.from(tbody.querySelectorAll('input.rowSel:checked'));
  if (checked.length === 0) return;
  checked.forEach(cb => { const tr = cb.closest('tr'); if (tr && tr.parentNode === tbody) tbody.removeChild(tr); });

  const selectAll = document.getElementById('selectAll'); if (selectAll) selectAll.checked = false;

  const rows = serializeTable();
  playHistoryMap = {}; lastInning = "";
  rows.forEach(r => {
    const vals = r.values || [];
    const nm = vals[2]; const m = makeShortPlay(vals);
    if (nm && m) pushPlayHistory(nm, vals[0] || "", m);
    if (!lastInning && vals[0]) lastInning = vals[0];
  });
  renderLineupSummary();
  scheduleSave();

  // â¬‡ï¸ ì‚­ì œ í›„ ì§‘ê³„ ê°±ì‹ 
  renderPlateAppearanceAvg_Offense();
  renderAdjSummary();
  renderLineupSummary();
}
function csvEscape(value) { const v = (value ?? "").toString(); return `"${v.replace(/"/g, '""')}"`; }
function tableToCSV() {
  const table = document.getElementById("logTable");
  const thead = table.tHead;
  const tbody = table.tBodies[0];

  const headerCells = Array.from(thead.rows[0].cells).slice(1);
  const headers = headerCells.map(th => th.textContent.trim());
  if (headers.length > 0) headers[0] = "ì„±ê³¼ê°ì²´ëª…";
  headers.push("ì¼ì •ëª…");

  const rows = [headers.map(csvEscape).join(",")];

  Array.from(tbody.rows).forEach(tr => {
    const cells = Array.from(tr.cells).slice(1);
    const vals = cells.map(td => td.textContent.trim());

    const seq = vals[0] || "";
    const perfCsv = (scheduleNameState ? `${scheduleNameState} ${seq}` : seq);
    vals[0] = perfCsv;
    vals.push(scheduleNameState || "");

    rows.push(vals.map(csvEscape).join(","));
  });

  return rows.join("\n");
}
function downloadCSV() {
  const csv = tableToCSV();

  const rawName =
    (typeof scheduleNameState === "string" && scheduleNameState.trim()) ||
    (document.getElementById("scheduleName")?.value?.trim()) ||
    "ì¼ì •ì—†ìŒ";
  const safeName = rawName.replace(/[\\\/:*?"<>|]/g, " ").replace(/\s+/g, " ").trim();
  const filename = `[Eagles Offense Log â€˜${safeName}â€™ ].csv`;

  const blob = new Blob(["\uFEFF" + csv], { type: "text/csv;charset=utf-8;" });
  const url = URL.createObjectURL(blob);
  const a = document.createElement("a");
  a.href = url; a.download = filename;
  document.body.appendChild(a); a.click(); document.body.removeChild(a);
  URL.revokeObjectURL(url);
}
function setSelectAllBehavior() {
  const selectAll = document.getElementById('selectAll');
  const tbody = document.getElementById("logTable").getElementsByTagName("tbody")[0];
  if (!selectAll) return;
  selectAll.addEventListener('change', () => {
    const boxes = tbody.querySelectorAll('input.rowSel');
    boxes.forEach(b => b.checked = selectAll.checked);
  });
  document.getElementById('deleteSelected').addEventListener('click', deleteSelectedRows);
  document.getElementById('exportCsv').addEventListener('click', downloadCSV);

 const copyBtn = document.getElementById('copyCsv');
  if (copyBtn) copyBtn.addEventListener('click', copyCSVToClipboard);
}

function bindResetAll(){
  const btn = document.getElementById("resetAll");
  btn.addEventListener("click", () => {
    const ok = confirm("ì •ë§ ì „ì²´ ì´ˆê¸°í™”í• ê¹Œìš”? (ë¼ì¸ì—…/ì§„í–‰ìƒíƒœ/ë¡œê·¸, ì €ì¥ë°ì´í„° ëª¨ë‘ ì‚­ì œ)");
    if (!ok) return;

    document.querySelector("#logTable tbody").innerHTML = "";
    logSeq = 0;

    lineupMap = {};
    lineupApplied = false;
    currentStep = 0;
    currentValues = [];
    eventType = "";

    playHistoryMap = {};
    lastInning = "";
    scheduleNameState = "";
    const scheduleInput = document.getElementById("scheduleName");
    if (scheduleInput) scheduleInput.value = "";

    document.getElementById("lineupInput").style.display = "block";
    document.getElementById('starterList').innerHTML = "";
    document.getElementById('benchList').innerHTML = "";
    document.getElementById('lineupSummary').style.display = "none";
    clearLineupInputs();
    steps[2].options = [];

    updateLegend(); updateCurrentInputLine(); updateStepProgress();
    updateScheduleBadge();
    clearAllStorage();

    // â¬‡ï¸ ì´ˆê¸°í™” í›„ ì§‘ê³„ ë¦¬ì…‹
    renderPlateAppearanceAvg_Offense();
    renderAdjSummary();
    renderLineupSummary();
  });
}

/* ====== ìŠ¤í… UI ====== */
function updateStepProgress() {
  const box = document.getElementById('stepProgress');
  if (!box) return;
  const html = steps.map((s, i) =>
    `<div class="stepBox ${i===currentStep ? 'active' : ''}">${i+1}. ${s.name}</div>`
  ).join('');
  box.innerHTML = html;
}
function updateCurrentInputLine() {
  const el = document.getElementById('currentInputLine');
  if (!el) return;
  const picked = currentValues.map(v => v || '-').join(' â†’ ');
  el.textContent = `[í˜„ì¬ ì…ë ¥ ì¤‘] â†’ ${picked}`;
}
function updateLegend() {
  const ul = document.getElementById('legendList');
  if (!ul) return;
  const step = steps[currentStep] || { options: [] };
  const opts = step.options || [];
  const items = opts.map((o, idx) => {
    if (typeof o === 'object' && o.key && o.label) {
      const color = (o.color === 'red' || o.color === 'green' || o.color === 'yellow') ? o.color : 'green';
      return `<li><span class="${color}">[${o.key}]</span> <span class="${color}">${o.label}</span></li>`;
    }
    return `<li><span class="">[${idx + 1}]</span> ${o}</li>`;
  });
  ul.innerHTML = items.join('') || '<li>-</li>';
}

/* ====== ì¢…ë£Œ ì €ì¥ ====== */
window.addEventListener("beforeunload", () => { try { saveAll(); } catch(e) {} });
</script>
</body>
</html>